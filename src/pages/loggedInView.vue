<script setup lang="ts">
import { AppMode } from '@arcana/auth'
import { LoginType } from '@arcana/auth-core/types/types'
import { ChainType } from '@arcana/auth/types/typings'
import { Core, SecurityQuestionModule } from '@arcana/key-helper'
import type { Connection } from 'penpal'
import { onMounted, ref } from 'vue'
import { onBeforeRouteLeave, useRouter } from 'vue-router'

import AppLoader from '@/components/AppLoader.vue'
import type { ParentConnectionApi } from '@/models/Connection'
import { CHAIN_LIST } from '@/models/RpcConfigList'
import { useAppStore } from '@/store/app'
import { useParentConnectionStore } from '@/store/parentConnection'
import { useRequestStore } from '@/store/request'
import { useRpcStore } from '@/store/rpc'
import { useUserStore } from '@/store/user'
import { GATEWAY_URL, AUTH_NETWORK } from '@/utils/constants'
import { createParentConnection } from '@/utils/createParentConnection'
import { EthereumAccountHandler } from '@/utils/evm/ethereumAccountHandler'
import {
  getEthereumRequestHandler,
  setEthereumRequestHandler,
} from '@/utils/evm/requestHandlerSingleton'
import {
  getSendRequestFn,
  handleRequest,
  watchRequestQueue,
} from '@/utils/evm/requestManagement'
import { getAuthProvider } from '@/utils/getAuthProvider'
import getValidAppMode from '@/utils/getValidAppMode'
import { getWalletType } from '@/utils/getwalletType'
import { getStorage } from '@/utils/storageWrapper'

const userStore = useUserStore()
const appStore = useAppStore()
const rpcStore = useRpcStore()
const showMfaBanner = ref(false)
const parentConnectionStore = useParentConnectionStore()
const requestStore = useRequestStore()
const router = useRouter()
const loader = ref({
  show: true,
  message: 'Loading...',
})
let parentConnection: Connection<ParentConnectionApi>
const storage = getStorage()

onBeforeMount(() => {
  userStore.hasMfa =
    getStorage().local.getItem(`${userStore.info.id}-has-mfa`) === '1'
})

onMounted(async () => {
  setRpcConfigs()
  await initKeeper()
  connectToParent()
  await setTheme()
  await getRpcConfig()
  await getAccountDetails()
  await setMFABannerState()
  await router.push({ name: 'home' })
  loader.value.show = false
})

async function setMFABannerState() {
  if (!userStore.hasMfa) {
    const userInfo = JSON.parse(storage.session.getItem('userInfo') as string)
    const core = new Core(
      userInfo.pk,
      userStore.info.id,
      appStore.id,
      GATEWAY_URL,
      AUTH_NETWORK === 'dev'
    )
    const securityQuestionModule = new SecurityQuestionModule(3)
    securityQuestionModule.init(core)
    const isEnabled = await securityQuestionModule.isEnabled()
    userStore.hasMfa = isEnabled
  }
  const mfaDnd = storage.local.getItem(`${userStore.info.id}-mfa-dnd`)
  const mfaSkipUntil = storage.local.getItem(
    `${userStore.info.id}-mfa-skip-until`
  )
  const loginCount = storage.local.getItem(`${userStore.info.id}-login-count`)
  const hasMfaDnd = mfaDnd && mfaDnd === '1'
  const hasMfaSkip =
    mfaSkipUntil && loginCount && Number(loginCount) < Number(mfaSkipUntil)
  if (!userStore.hasMfa && !hasMfaDnd && !hasMfaSkip) {
    showMfaBanner.value = true
  }
}

async function getAccountDetails() {
  await initAccountHandler()
}

async function initKeeper() {
  const pc = await parentConnection.promise
  const cfg = await pc.getAppConfig()

  switch (cfg.chainType) {
    case ChainType.ethereum_secp256k1: {
      const accountHandler = new EthereumAccountHandler(
        userStore.privateKey,
        rpcStore.selectedRpcConfig.rpcUrls[0]
      )
      setEthereumRequestHandler(accountHandler)
    }
  }
}

async function initAccountHandler() {
  try {
    if (parentConnection) {
      const parentConnectionInstance = await parentConnection.promise

      if (!userStore.walletAddress) {
        const account = getEthereumRequestHandler()
          .getAccountHandler()
          .getAccount()
        userStore.setWalletAddress(account.address)
      }

      if (typeof appStore.validAppMode !== 'number') {
        const walletType = await getWalletType(appStore.id)
        setAppMode(walletType, parentConnectionInstance)
      }

      const requestHandler = getEthereumRequestHandler()
      if (requestHandler) {
        requestHandler.setConnection(parentConnection)
        const { chainId, ...rpcConfig } = rpcStore.selectedRpcConfig
        const selectedChainId = Number(chainId)
        await requestHandler.setRpcConfig({
          chainId: selectedChainId,
          ...rpcConfig,
        })

        watchRequestQueue(requestHandler)

        parentConnectionInstance.onEvent('connect', {
          chainId: selectedChainId,
        })
      }
    }
  } catch (err) {
    console.log({ err })
  }
}

function connectToParent() {
  const sendRequest = getSendRequestFn(
    handleRequest,
    requestStore,
    appStore,
    getEthereumRequestHandler()
  )
  parentConnection = createParentConnection({
    isLoggedIn: () => userStore.isLoggedIn,
    sendRequest,
    getPublicKey: handleGetPublicKey,
    triggerLogout: handleLogout,
    getUserInfo,
  })
  parentConnectionStore.setParentConnection(parentConnection)
}

async function setTheme() {
  if (parentConnection) {
    const parentConnectionInstance = await parentConnection.promise
    const {
      themeConfig: { theme },
      name: appName,
    } = await parentConnectionInstance.getAppConfig()

    appStore.setTheme(theme)
    appStore.setName(appName)
    const htmlEl = document.getElementsByTagName('html')[0]
    if (theme === 'dark') htmlEl.classList.add(theme)
  }
}

function getUserInfo() {
  const accountDetails = getEthereumRequestHandler()
    .getAccountHandler()
    .getAccount()
  return {
    ...userStore.info,
    ...accountDetails,
  }
}

async function setAppMode(walletType, parentConnectionInstance) {
  const appModeFromParent = await parentConnectionInstance.getAppMode()
  const validAppMode = getValidAppMode(walletType, appModeFromParent)
  appStore.setAppMode(validAppMode as AppMode)
}

async function handleLogout(isV2 = false) {
  if (parentConnection) {
    const parentConnectionInstance = await parentConnection.promise
    const authProvider = await getAuthProvider(appStore.id as string)
    await userStore.handleLogout(authProvider)
    parentConnectionInstance?.onEvent('disconnect')
    setTimeout(() => {
      const route = isV2 ? `/${appStore.id}/v2/login` : `/${appStore.id}/login`
      router.push(route)
    })
  }
}

function setRpcConfigs() {
  if (!rpcStore.rpcConfigs) rpcStore.setRpcConfigs(CHAIN_LIST)
}

async function getRpcConfig() {
  try {
    if (parentConnection) {
      const parentConnectionInstance = await parentConnection.promise
      let rpcConfig = await parentConnectionInstance.getRpcConfig()
      if ([40404, 40405].includes(Number(rpcConfig.chainId))) {
        rpcConfig = CHAIN_LIST[0]
      }
      if (rpcConfig) {
        const selectedChain = CHAIN_LIST.find(
          (chain) => Number(chain.chainId) === Number(rpcConfig.chainId)
        )
        rpcStore.setSelectedRPCConfig({
          ...rpcConfig,
          favicon: selectedChain ? selectedChain.favicon : 'blockchain-icon',
          isCustom: false,
        })
        rpcStore.setRpcConfig({
          ...rpcConfig,
          favicon: selectedChain ? selectedChain.favicon : 'blockchain-icon',
          isCustom: false,
        })
      }
    }
  } catch (err) {
    console.log({ err })
  }
}

async function handleGetPublicKey(id: string, verifier: LoginType) {
  const authProvider = await getAuthProvider(appStore.id as string)
  return await authProvider.getPublicKey({ id, verifier })
}

function handleSkip() {
  const loginCount = storage.local.getItem(`${userStore.info.id}-login-count`)
  const skipUntil = loginCount ? Number(loginCount) + 3 : 3
  storage.local.setItem(
    `${userStore.info.id}-mfa-skip-until`,
    String(skipUntil)
  )
  showMfaBanner.value = false
}

function handleMFACreation() {
  router.push({ name: 'MFARequired' })
  showMfaBanner.value = false
}

onBeforeRouteLeave((to) => {
  if (to.path.includes('login')) parentConnection?.destroy()
})
</script>

<template>
  <div v-if="loader.show" class="flex justify-center items-center flex-1">
    <AppLoader :message="loader.message" />
  </div>
  <div v-else class="flex flex-col gap-2">
    <Transition name="fade" mode="out-in">
      <button
        v-if="showMfaBanner"
        class="bg-blue-700 rounded-lg p-4 flex justify-between items-center cursor-pointer"
        @click.stop="handleMFACreation"
      >
        <div class="flex items-center gap-2">
          <span class="font-semibold text-white text-sm"
            >Enhance your wallet security</span
          >
          <img src="@/assets/images/export.svg" class="w-5" />
        </div>
        <img
          src="@/assets/images/close-icon.svg"
          class="w-6 -mr-[0.5rem]"
          @click.stop="handleSkip"
        />
      </button>
    </Transition>
    <RouterView v-slot="{ Component }" class="flex-grow w-full">
      <Transition name="fade" mode="out-in">
        <component :is="Component" />
      </Transition>
    </RouterView>
  </div>
</template>
